import { __rest } from "tslib";
import { useRef, useCallback, useMemo, useEffect, useState } from 'react';
import useAsync from './useAsync';
import useUpdateEffect from './utils/useUpdateEffect';

function useLoadMore(service, options) {
  var _options$refreshDeps = options.refreshDeps,
      refreshDeps = _options$refreshDeps === void 0 ? [] : _options$refreshDeps,
      ref = options.ref,
      isNoMore = options.isNoMore,
      _options$threshold = options.threshold,
      threshold = _options$threshold === void 0 ? 100 : _options$threshold,
      fetchKey = options.fetchKey,
      restOptions = __rest(options, ["refreshDeps", "ref", "isNoMore", "threshold", "fetchKey"]);

  var _useState = useState(false),
      loadingMore = _useState[0],
      setLoadingMore = _useState[1];

  useEffect(function () {
    if (options.fetchKey) {
      console.warn("useRequest loadMore mode don't need fetchKey!");
    }
  }, []);
  var result = useAsync(service, Object.assign(Object.assign({}, restOptions), {
    fetchKey: function fetchKey(d) {
      var _a;

      return ((_a = d === null || d === void 0 ? void 0 : d.list) === null || _a === void 0 ? void 0 : _a.length) || 0;
    },
    onSuccess: function onSuccess() {
      setLoadingMore(false);

      if (options.onSuccess) {
        options.onSuccess.apply(options, arguments);
      }
    }
  }));
  var data = result.data,
      run = result.run,
      params = result.params,
      reset = result.reset,
      loading = result.loading,
      fetches = result.fetches;
  var reload = useCallback(function () {
    reset();
    var restParams = params.slice(1);
    run.apply(void 0, [undefined].concat(restParams));
  }, [run, reset, params]);
  var reloadRef = useRef(reload);
  reloadRef.current = reload;
  /* loadMore 场景下，如果 refreshDeps 变化，重置到第一页 */

  useUpdateEffect(function () {
    /* 只有自动执行的场景， refreshDeps 才有效 */
    if (!options.manual) {
      reloadRef.current();
    }
  }, [].concat(refreshDeps));
  var dataGroup = useMemo(function () {
    var listGroup = []; // 在 loadMore 时，不希望清空上一次的 data。需要把最后一个 非 loading 的请求 data，放回去。

    var lastNoLoadingData = data;
    Object.values(fetches).forEach(function (h) {
      var _a, _b;

      if ((_a = h.data) === null || _a === void 0 ? void 0 : _a.list) {
        listGroup = listGroup.concat((_b = h.data) === null || _b === void 0 ? void 0 : _b.list);
      }

      if (!h.loading) {
        lastNoLoadingData = h.data;
      }
    });
    return Object.assign(Object.assign({}, lastNoLoadingData), {
      list: listGroup
    });
  }, [fetches, data]);
  var noMore = isNoMore ? !loading && !loadingMore && isNoMore(dataGroup) : false;
  var loadMore = useCallback(function () {
    if (noMore) {
      return;
    }

    setLoadingMore(true);
    var restParams = params.slice(1);
    run.apply(void 0, [dataGroup].concat(restParams));
  }, [noMore, run, dataGroup, params]);
  /* 上拉加载的方法 */

  var scrollMethod = useCallback(function () {
    if (loading || loadingMore || !ref || !ref.current) {
      return;
    }

    if (ref.current.scrollHeight - ref.current.scrollTop <= ref.current.clientHeight + threshold) {
      loadMore();
    }
  }, [loading, ref, loadMore]);
  /* 如果有 ref，则会上拉加载更多 */

  useEffect(function () {
    if (!ref || !ref.current) {
      return function () {};
    }

    ref.current.addEventListener('scroll', scrollMethod);
    return function () {
      if (ref && ref.current) {
        ref.current.removeEventListener('scroll', scrollMethod);
      }
    };
  }, [scrollMethod]);
  return Object.assign(Object.assign({}, result), {
    data: dataGroup,
    reload: reload,
    loading: loading && dataGroup.list.length === 0,
    loadMore: loadMore,
    loadingMore: loadingMore,
    noMore: noMore
  });
}

export default useLoadMore;