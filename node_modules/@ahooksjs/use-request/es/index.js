import { __rest } from "tslib";
/* eslint-disable react-hooks/rules-of-hooks */

import { useRef, useContext } from 'react';
import useAsync from './useAsync';
import useLoadMore from './useLoadMore';
import usePaginated from './usePaginated';
import ConfigContext from './configContext';

function useRequest(service, options) {
  if (options === void 0) {
    options = {};
  }

  var contextConfig = useContext(ConfigContext);
  var finalOptions = Object.assign(Object.assign({}, contextConfig), options);
  var paginated = finalOptions.paginated,
      loadMore = finalOptions.loadMore,
      requestMethod = finalOptions.requestMethod;
  var paginatedRef = useRef(paginated);
  var loadMoreRef = useRef(loadMore);

  if (paginatedRef.current !== paginated) {
    throw Error('You should not modify the paginated of options');
  }

  if (loadMoreRef.current !== loadMore) {
    throw Error('You should not modify the loadMore of options');
  }

  paginatedRef.current = paginated;
  loadMoreRef.current = loadMore; // @ts-ignore

  var fetchProxy = function fetchProxy() {
    return (// @ts-ignore
      fetch.apply(void 0, arguments).then(function (res) {
        if (res.ok) {
          return res.json();
        }

        throw new Error(res.statusText);
      })
    );
  };

  var finalRequestMethod = requestMethod || fetchProxy;
  var promiseService;

  if (typeof service === 'string') {
    promiseService = function promiseService() {
      return finalRequestMethod(service);
    };
  } else if (typeof service === 'object') {
    var url = service.url,
        rest = __rest(service, ["url"]);

    promiseService = function promiseService() {
      return requestMethod ? requestMethod(service) : fetchProxy(url, rest);
    };
  } else {
    promiseService = function promiseService() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return new Promise(function (resolve, reject) {
        var result = service.apply(void 0, args);

        if (result.then) {
          result.then(function (data) {
            return resolve(data);
          })["catch"](function (e) {
            return reject(e);
          });
        } else if (typeof result === 'string') {
          finalRequestMethod(result).then(function (data) {
            resolve(data);
          })["catch"](function (e) {
            return reject(e);
          });
        } else if (typeof result === 'object') {
          // fetch 需要拆分下字段
          if (requestMethod) {
            requestMethod(result).then(function (data) {
              resolve(data);
            })["catch"](function (e) {
              return reject(e);
            });
          } else {
            var _url = result.url,
                _rest = __rest(result, ["url"]);

            fetchProxy(_url, _rest).then(function (data) {
              resolve(data);
            })["catch"](function (e) {
              return reject(e);
            });
          }
        }
      });
    };
  }

  if (loadMore) {
    return useLoadMore(promiseService, finalOptions);
  }

  if (paginated) {
    return usePaginated(promiseService, finalOptions);
  }

  return useAsync(promiseService, finalOptions);
}

var UseRequestProvider = ConfigContext.Provider; // UseAPIProvider 已经废弃，此处为了兼容 umijs 插件 plugin-request

var UseAPIProvider = UseRequestProvider;
export { useAsync, usePaginated, useLoadMore, UseRequestProvider, UseAPIProvider };
export default useRequest;