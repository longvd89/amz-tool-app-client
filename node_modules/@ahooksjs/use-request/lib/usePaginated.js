"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = require("tslib");

var react_1 = require("react");

var useAsync_1 = tslib_1.__importDefault(require("./useAsync"));

var useUpdateEffect_1 = tslib_1.__importDefault(require("./utils/useUpdateEffect"));

function usePaginated(service, options) {
  var paginated = options.paginated,
      _options$defaultPageS = options.defaultPageSize,
      defaultPageSize = _options$defaultPageS === void 0 ? 10 : _options$defaultPageS,
      _options$refreshDeps = options.refreshDeps,
      refreshDeps = _options$refreshDeps === void 0 ? [] : _options$refreshDeps,
      fetchKey = options.fetchKey,
      restOptions = tslib_1.__rest(options, ["paginated", "defaultPageSize", "refreshDeps", "fetchKey"]);

  react_1.useEffect(function () {
    if (fetchKey) {
      console.error("useRequest pagination's fetchKey will not work!");
    }
  }, []);

  var _a = useAsync_1["default"](service, Object.assign({
    defaultParams: [{
      current: 1,
      pageSize: defaultPageSize
    }]
  }, restOptions)),
      data = _a.data,
      params = _a.params,
      run = _a.run,
      loading = _a.loading,
      rest = tslib_1.__rest(_a, ["data", "params", "run", "loading"]);

  var _ref = params && params[0] ? params[0] : {},
      _ref$current = _ref.current,
      current = _ref$current === void 0 ? 1 : _ref$current,
      _ref$pageSize = _ref.pageSize,
      pageSize = _ref$pageSize === void 0 ? defaultPageSize : _ref$pageSize,
      _ref$sorter = _ref.sorter,
      sorter = _ref$sorter === void 0 ? {} : _ref$sorter,
      _ref$filters = _ref.filters,
      filters = _ref$filters === void 0 ? {} : _ref$filters; // 只改变 pagination，其他参数原样传递


  var runChangePaination = react_1.useCallback(function (paginationParams) {
    var oldPaginationParams = params[0],
        restParams = params.slice(1);
    run.apply(void 0, [Object.assign(Object.assign({}, oldPaginationParams), paginationParams)].concat(restParams));
  }, [run, params]);
  var total = (data === null || data === void 0 ? void 0 : data.total) || 0;
  var totalPage = react_1.useMemo(function () {
    return Math.ceil(total / pageSize);
  }, [pageSize, total]);
  var onChange = react_1.useCallback(function (c, p) {
    var toCurrent = c <= 0 ? 1 : c;
    var toPageSize = p <= 0 ? 1 : p;
    var tempTotalPage = Math.ceil(total / toPageSize);

    if (toCurrent > tempTotalPage) {
      toCurrent = tempTotalPage;
    }

    runChangePaination({
      current: c,
      pageSize: p
    });
  }, [total, runChangePaination]);
  var changeCurrent = react_1.useCallback(function (c) {
    onChange(c, pageSize);
  }, [onChange, pageSize]);
  var changePageSize = react_1.useCallback(function (p) {
    onChange(current, p);
  }, [onChange, current]);
  var changeCurrentRef = react_1.useRef(changeCurrent);
  changeCurrentRef.current = changeCurrent;
  /* 分页场景下，如果 refreshDeps 变化，重置分页 */

  useUpdateEffect_1["default"](function () {
    /* 只有自动执行的场景， refreshDeps 才有效 */
    if (!options.manual) {
      changeCurrentRef.current(1);
    }
  }, [].concat(refreshDeps)); // 表格翻页 排序 筛选等

  var changeTable = react_1.useCallback(function (p, f, s) {
    runChangePaination({
      current: p.current,
      pageSize: p.pageSize || defaultPageSize,
      filters: f,
      sorter: s
    });
  }, [filters, sorter, runChangePaination]);
  return Object.assign({
    loading: loading,
    data: data,
    params: params,
    run: run,
    pagination: {
      current: current,
      pageSize: pageSize,
      total: total,
      totalPage: totalPage,
      onChange: onChange,
      changeCurrent: changeCurrent,
      changePageSize: changePageSize
    },
    tableProps: {
      dataSource: (data === null || data === void 0 ? void 0 : data.list) || [],
      loading: loading,
      onChange: changeTable,
      pagination: {
        current: current,
        pageSize: pageSize,
        total: total
      }
    },
    sorter: sorter,
    filters: filters
  }, rest);
}

exports["default"] = usePaginated;